{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Nebula Nebula is an open-source simulator of electron-matter interaction. It can run on GPUs for fast simulations, or on multi-core CPUs if there is no GPU available. If you use Nebula in a scientific publication, please cite the following paper: L. van Kessel, C.W. Hagen, \"Nebula: Monte Carlo simulator of electron-matter interaction\" , SoftwareX 12 (2020), 100605 The code is available on github . Getting started Nebula consists of two parts: the simulator itself and the \"cross-section tool\", cstool , that is used for compiling material parameters. You need to run cstool once per material, and then use the resulting file as an input for the simulator. Quick start links Installing cstool Running cstool Installing Nebula Your first simulation run In-depth file format documentation Geometry file format Electron file format Material parameter file format","title":"Home"},{"location":"#welcome-to-nebula","text":"Nebula is an open-source simulator of electron-matter interaction. It can run on GPUs for fast simulations, or on multi-core CPUs if there is no GPU available. If you use Nebula in a scientific publication, please cite the following paper: L. van Kessel, C.W. Hagen, \"Nebula: Monte Carlo simulator of electron-matter interaction\" , SoftwareX 12 (2020), 100605 The code is available on github .","title":"Welcome to Nebula"},{"location":"#getting-started","text":"Nebula consists of two parts: the simulator itself and the \"cross-section tool\", cstool , that is used for compiling material parameters. You need to run cstool once per material, and then use the resulting file as an input for the simulator.","title":"Getting started"},{"location":"#quick-start-links","text":"Installing cstool Running cstool Installing Nebula Your first simulation run","title":"Quick start links"},{"location":"#in-depth-file-format-documentation","text":"Geometry file format Electron file format Material parameter file format","title":"In-depth file format documentation"},{"location":"cstool-format-elf/","text":"cstool optical data file format cstool needs optical data to represent the probability of electron energy loss in a material. The specific optical data we need is the dielectric function, or n and k values as they are sometimes known. Sourcing the data Good sources for optical data include: The book Handbook of Optical Constants of Solids by E.D. Palik The website refractiveindex.info The CXRO database for high energy photons (30 eV and beyond). In the visible light range, the dielectric function is often given as n and k values. They are related to the dielectric function by \u03f5 = (n + ik)\u00b2 where i is the imaginary unit. In the X-ray range, the popular parameters are \u03b4 and \u03b2 . They are related to n and k by n = 1 - \u03b4 k = \u03b2 Note that the CXRO website is incorrect: it has a header saying that k = -\u03b2, but that's not true. Nebula needs to know the energy loss function (ELF), equal to ELF = Im(-1/\u03f5) Loosely speaking, the ELF reflects the probability that an electron loses a certain amount of energy. Therefore, an accurate simulation requires this optical data to be tabulated over a very large range of photon energies, from sub-eV to the highest energy of interest (typically in the keV range). The file format We use an older file format first used in the simulator of Kieft and Bosch . Such a file may look as follows: 1.12 5 8.9 100 1839 -1 0.01116 1.45249E-05 0.04959 4.57441E-06 [snip] 4000 5.12708E-06 8000 3.54308E-07 -1 -1 The first line contains binding energies of electrons. This is only relevant for the semi-empirical model of Kieft and Bosch, which we don't reccommend to use. These energies are in units of electronvolts, the list is terminated by -1. If you are not interested in the model by Kieft and Bosch, a line with only -1 is sufficient. (It must be present, though!) The lines below that have two columns. The first value is the photon energy in eV. The second value is the ELF (which is unitless). Finally, the last line is two times -1. This line must always be there.","title":"Optical data file format"},{"location":"cstool-format-elf/#cstool-optical-data-file-format","text":"cstool needs optical data to represent the probability of electron energy loss in a material. The specific optical data we need is the dielectric function, or n and k values as they are sometimes known.","title":"cstool optical data file format"},{"location":"cstool-format-elf/#sourcing-the-data","text":"Good sources for optical data include: The book Handbook of Optical Constants of Solids by E.D. Palik The website refractiveindex.info The CXRO database for high energy photons (30 eV and beyond). In the visible light range, the dielectric function is often given as n and k values. They are related to the dielectric function by \u03f5 = (n + ik)\u00b2 where i is the imaginary unit. In the X-ray range, the popular parameters are \u03b4 and \u03b2 . They are related to n and k by n = 1 - \u03b4 k = \u03b2 Note that the CXRO website is incorrect: it has a header saying that k = -\u03b2, but that's not true. Nebula needs to know the energy loss function (ELF), equal to ELF = Im(-1/\u03f5) Loosely speaking, the ELF reflects the probability that an electron loses a certain amount of energy. Therefore, an accurate simulation requires this optical data to be tabulated over a very large range of photon energies, from sub-eV to the highest energy of interest (typically in the keV range).","title":"Sourcing the data"},{"location":"cstool-format-elf/#the-file-format","text":"We use an older file format first used in the simulator of Kieft and Bosch . Such a file may look as follows: 1.12 5 8.9 100 1839 -1 0.01116 1.45249E-05 0.04959 4.57441E-06 [snip] 4000 5.12708E-06 8000 3.54308E-07 -1 -1 The first line contains binding energies of electrons. This is only relevant for the semi-empirical model of Kieft and Bosch, which we don't reccommend to use. These energies are in units of electronvolts, the list is terminated by -1. If you are not interested in the model by Kieft and Bosch, a line with only -1 is sufficient. (It must be present, though!) The lines below that have two columns. The first value is the photon energy in eV. The second value is the ELF (which is unitless). Finally, the last line is two times -1. This line must always be there.","title":"The file format"},{"location":"cstool-format-yaml/","text":"cstool parameter file format Parameters for cstool are provided in the YAML text format. An example paramter file is: name: alumina density: 3.98 g/cm\u00b3 elements: Al: { count: 2, Z: 13, M: 26.982 g/mol } O: { count: 3, Z: 8, M: 15.999 g/mol } band_structure: model: insulator valence: 3.64 eV band_gap: 7.0 eV affinity: 3.71 eV optical: df_file: elf/df_Al2O3.dat phonon: lattice: 4.76 \u00c5 isotropic: ac_def: 13.0 eV longitudinal: c_s: 11003 m/s transversal: c_s: 6512 m/s Generic parameters The following generic parameters are required: Name Density These parameters speak for themselves. Element list Next in the example file is the list of elements in the material. Each element should have its own entry; each entry should look like this: Al: { count: 2, Z: 13, M: 26.982 g/mol } Al is the name of the element. This is not used by cstool, but you should use a reasonable name for the benefit of other humans. count is the number of atoms per unit cell Z is the atomic number M is the average atomic mass Band structure We use a very simplistic band structure model. Metals have a single band, the conduction band. Semiconductors and insulators have two bands, the valence and conduction bands, with a band gap in between. The parameter you need to provide is model , which can be metal , semiconductor or insulator . The semiconductor and insulator models are actually equivalent. If the model is metal , the following parameters are required: fermi : The position of the Fermi energy, with respect to the bottom of the conduction band work_function : The work function If the model is semiconductor or insulator , we need the following parameters: valence : the width of the valence band band_gap : the band gap affinity : the electron affinity Optical Only one parameter is possible here, df_file . This is the file name with optical parameters. The exact file format of that file is described here . Phonon These are parameters for the electron-acoustic phonon scattering model of Schreiber and Fitting . The phonon section may look as follows (parameters are for silicon): phonon: lattice: 5.43071 \u00c5 m_dos: 1.08 m_e m_eff: 0.26 m_e longitudinal: alpha: 2.00e-7 m\u00b2/s c_s: 9130 m/s ac_def: 9.2 eV transversal: alpha: 2.26e-7 m\u00b2/s c_s: 5842 m/s ac_def: 5.0 eV One parameter is always required: lattice , which is the material's lattice constant. Two parameters are optional: m_eff : the effective mass of the electron m_dos : the density-of-states mass of the electron If these are not provided, they are set to the electron rest mass in vacuum. There are three phonon modes: two transverse and a longitudinal one. Per mode, two parameters are required: c_s : the speed of sound ac_def : the acoustic deformation potential Another parameter is optional: alpha , with units of m\u00b2/s, describes the band bending of the phonon dispersion relation near the Brillouin zone edge. This is zero by default. In practice, it is very difficult to find the acoustic deformation potential in literature. If it is available, it is often an effective value combining the longitudinal and transverse modes. If that happens, you can provide the ac_def , c_s and alpha parameters in an isotropic branch instead of the longitudinal and transverse branches separately. If you do have separate longitudinal and transverse speeds of sounds, you can provide these in their respective branches, and cstool will automatically combine them with the isotropic acoustic deformation potential. This has happened in the parameter file all the way at the top of this page. Finally, for metals, there is a way to estimate the acoustic deformation potential using the resistivity (which is much easier to find). Instead of providing ac_def in the isotropic branch, you may provide a resistivity parameter. The phonon section may then look as follows (parameters are for gold): phonon: lattice: 4.0782 \u00c5 isotropic: resistivity: 2.44e-8 \u03a9 m longitudinal: c_s: 3240 m/s transversal: c_s: 1200 m/s","title":"Parameter file format"},{"location":"cstool-format-yaml/#cstool-parameter-file-format","text":"Parameters for cstool are provided in the YAML text format. An example paramter file is: name: alumina density: 3.98 g/cm\u00b3 elements: Al: { count: 2, Z: 13, M: 26.982 g/mol } O: { count: 3, Z: 8, M: 15.999 g/mol } band_structure: model: insulator valence: 3.64 eV band_gap: 7.0 eV affinity: 3.71 eV optical: df_file: elf/df_Al2O3.dat phonon: lattice: 4.76 \u00c5 isotropic: ac_def: 13.0 eV longitudinal: c_s: 11003 m/s transversal: c_s: 6512 m/s","title":"cstool parameter file format"},{"location":"cstool-format-yaml/#generic-parameters","text":"The following generic parameters are required: Name Density These parameters speak for themselves.","title":"Generic parameters"},{"location":"cstool-format-yaml/#element-list","text":"Next in the example file is the list of elements in the material. Each element should have its own entry; each entry should look like this: Al: { count: 2, Z: 13, M: 26.982 g/mol } Al is the name of the element. This is not used by cstool, but you should use a reasonable name for the benefit of other humans. count is the number of atoms per unit cell Z is the atomic number M is the average atomic mass","title":"Element list"},{"location":"cstool-format-yaml/#band-structure","text":"We use a very simplistic band structure model. Metals have a single band, the conduction band. Semiconductors and insulators have two bands, the valence and conduction bands, with a band gap in between. The parameter you need to provide is model , which can be metal , semiconductor or insulator . The semiconductor and insulator models are actually equivalent. If the model is metal , the following parameters are required: fermi : The position of the Fermi energy, with respect to the bottom of the conduction band work_function : The work function If the model is semiconductor or insulator , we need the following parameters: valence : the width of the valence band band_gap : the band gap affinity : the electron affinity","title":"Band structure"},{"location":"cstool-format-yaml/#optical","text":"Only one parameter is possible here, df_file . This is the file name with optical parameters. The exact file format of that file is described here .","title":"Optical"},{"location":"cstool-format-yaml/#phonon","text":"These are parameters for the electron-acoustic phonon scattering model of Schreiber and Fitting . The phonon section may look as follows (parameters are for silicon): phonon: lattice: 5.43071 \u00c5 m_dos: 1.08 m_e m_eff: 0.26 m_e longitudinal: alpha: 2.00e-7 m\u00b2/s c_s: 9130 m/s ac_def: 9.2 eV transversal: alpha: 2.26e-7 m\u00b2/s c_s: 5842 m/s ac_def: 5.0 eV One parameter is always required: lattice , which is the material's lattice constant. Two parameters are optional: m_eff : the effective mass of the electron m_dos : the density-of-states mass of the electron If these are not provided, they are set to the electron rest mass in vacuum. There are three phonon modes: two transverse and a longitudinal one. Per mode, two parameters are required: c_s : the speed of sound ac_def : the acoustic deformation potential Another parameter is optional: alpha , with units of m\u00b2/s, describes the band bending of the phonon dispersion relation near the Brillouin zone edge. This is zero by default. In practice, it is very difficult to find the acoustic deformation potential in literature. If it is available, it is often an effective value combining the longitudinal and transverse modes. If that happens, you can provide the ac_def , c_s and alpha parameters in an isotropic branch instead of the longitudinal and transverse branches separately. If you do have separate longitudinal and transverse speeds of sounds, you can provide these in their respective branches, and cstool will automatically combine them with the isotropic acoustic deformation potential. This has happened in the parameter file all the way at the top of this page. Finally, for metals, there is a way to estimate the acoustic deformation potential using the resistivity (which is much easier to find). Instead of providing ac_def in the isotropic branch, you may provide a resistivity parameter. The phonon section may then look as follows (parameters are for gold): phonon: lattice: 4.0782 \u00c5 isotropic: resistivity: 2.44e-8 \u03a9 m longitudinal: c_s: 3240 m/s transversal: c_s: 1200 m/s","title":"Phonon"},{"location":"cstool-install/","text":"Installing cstool Requirements cstool is a Python 3 tool. It depends on ELSEPA, which you need to compile and install yourself. Before you begin, be sure that the following software is installed: Python 3.5 or greater On Linux: a fortran77 compiler All required python packages can be easily installed via pip. Download and compile ELSEPA On Linux Download ELSEPA from the official website. Unpack the archive, and compile the software with the following commands: gfortran -O -Wall elscata.f -o elscata gfortran -O -Wall elscatm.f -o elscatm Then, add the folder containing ELSEPA to your PATH environment variable, so that cstool will be able to find it. This can be done with the following: export PATH=$PATH:/path/to/elsepa It is often a good idea to add this line to the .bashrc file in your home directory, otherwise you will have to do this every time you start a new terminal session. On Windows It is possible to compile ELSEPA yourself on Windows by installing a fortran compiler. Alternatively, you can get a zip file with pre-compiled executables here . Extract the zip file, and add the folder to the PATH environment variable by doing this every time you run cstool: set PATH=%PATH%;C:\\path\\to\\elsepa; Download and install cstool On Linux Get the code from github: git clone https://github.com/nebula-simulator/cstool You are now recommended to create a virtual environment, so that you don't contaminate your regular python setup when you install cstool: python -m venv cstool-env source cstool-env/bin/activate pip install --upgrade pip Then install cstool: cd cstool pip install . On Windows Instructions will follow... Run cstool See the next page for instructions on running cstool.","title":"Installation"},{"location":"cstool-install/#installing-cstool","text":"","title":"Installing cstool"},{"location":"cstool-install/#requirements","text":"cstool is a Python 3 tool. It depends on ELSEPA, which you need to compile and install yourself. Before you begin, be sure that the following software is installed: Python 3.5 or greater On Linux: a fortran77 compiler All required python packages can be easily installed via pip.","title":"Requirements"},{"location":"cstool-install/#download-and-compile-elsepa","text":"","title":"Download and compile ELSEPA"},{"location":"cstool-install/#on-linux","text":"Download ELSEPA from the official website. Unpack the archive, and compile the software with the following commands: gfortran -O -Wall elscata.f -o elscata gfortran -O -Wall elscatm.f -o elscatm Then, add the folder containing ELSEPA to your PATH environment variable, so that cstool will be able to find it. This can be done with the following: export PATH=$PATH:/path/to/elsepa It is often a good idea to add this line to the .bashrc file in your home directory, otherwise you will have to do this every time you start a new terminal session.","title":"On Linux"},{"location":"cstool-install/#on-windows","text":"It is possible to compile ELSEPA yourself on Windows by installing a fortran compiler. Alternatively, you can get a zip file with pre-compiled executables here . Extract the zip file, and add the folder to the PATH environment variable by doing this every time you run cstool: set PATH=%PATH%;C:\\path\\to\\elsepa;","title":"On Windows"},{"location":"cstool-install/#download-and-install-cstool","text":"","title":"Download and install cstool"},{"location":"cstool-install/#on-linux_1","text":"Get the code from github: git clone https://github.com/nebula-simulator/cstool You are now recommended to create a virtual environment, so that you don't contaminate your regular python setup when you install cstool: python -m venv cstool-env source cstool-env/bin/activate pip install --upgrade pip Then install cstool: cd cstool pip install .","title":"On Linux"},{"location":"cstool-install/#on-windows_1","text":"Instructions will follow...","title":"On Windows"},{"location":"cstool-install/#run-cstool","text":"See the next page for instructions on running cstool.","title":"Run cstool"},{"location":"cstool-run/","text":"Running cstool Before every run You need to prepare your environment before running cstool. On Linux Activate the python environment: source cstool-env/bin/activate Make sure ELSEPA is in your path. If you did not put the following line in your .bashrc file, make sure you do it every time you start a new terminal session: export PATH=$PATH:/path/to/elsepa On Windows Instructions will follow... Generating material files Material files are compiled from a set of parameters, which are in the yaml text format. Parameter files for a set of relevant materials are provided in the data/materials folder. Detailed documentation of these files can be found here . After activating the environment, creating the material files is a matter of navigating to the right folder and running the cstool program: cd data/materials cstool silicon.yaml The tool should run for several minutes and generate a file silicon.mat . This is the material file that can be passed to the main simulator.","title":"Running"},{"location":"cstool-run/#running-cstool","text":"","title":"Running cstool"},{"location":"cstool-run/#before-every-run","text":"You need to prepare your environment before running cstool.","title":"Before every run"},{"location":"cstool-run/#on-linux","text":"Activate the python environment: source cstool-env/bin/activate Make sure ELSEPA is in your path. If you did not put the following line in your .bashrc file, make sure you do it every time you start a new terminal session: export PATH=$PATH:/path/to/elsepa","title":"On Linux"},{"location":"cstool-run/#on-windows","text":"Instructions will follow...","title":"On Windows"},{"location":"cstool-run/#generating-material-files","text":"Material files are compiled from a set of parameters, which are in the yaml text format. Parameter files for a set of relevant materials are provided in the data/materials folder. Detailed documentation of these files can be found here . After activating the environment, creating the material files is a matter of navigating to the right folder and running the cstool program: cd data/materials cstool silicon.yaml The tool should run for several minutes and generate a file silicon.mat . This is the material file that can be passed to the main simulator.","title":"Generating material files"},{"location":"nebula-format-pri/","text":"Nebula electron file format By \"electron file format\", we mean both the input format of primary electrons, and the output format of detected electrons. It is a binary file format. Each electron is described by nine numbers. The first seven are its x,y,z coordinates (in nm), its direction vector (the length is not neccesarily one), and the energy in eV. The last two numbers are integers that can be used to \"tag\" an electron, and are free to choose by the user. If an electron creates a secondary electron during the simulation, this secondary electron will get the same two tags. For example, these tags can be used for the x and y pixel indices of a SEM image. The first seven numbers are supplied as 32-bit floating point numbers. The tags are 32-bit signed integers. The endianness is the same as the system you are running on. If you are working with python, the relevant numpy datatype is the following: import numpy as np electron_dtype = np.dtype([ ('x', '=f'), ('y', '=f'), ('z', '=f'), ('dx', '=f'), ('dy', '=f'), ('dz', '=f'), ('E', '=f'), ('px', '=i'), ('py', '=i')]) Example scripts showing how to read and write electron files are provided with the tutorials and in the scripts repository .","title":"Electron file format"},{"location":"nebula-format-pri/#nebula-electron-file-format","text":"By \"electron file format\", we mean both the input format of primary electrons, and the output format of detected electrons. It is a binary file format. Each electron is described by nine numbers. The first seven are its x,y,z coordinates (in nm), its direction vector (the length is not neccesarily one), and the energy in eV. The last two numbers are integers that can be used to \"tag\" an electron, and are free to choose by the user. If an electron creates a secondary electron during the simulation, this secondary electron will get the same two tags. For example, these tags can be used for the x and y pixel indices of a SEM image. The first seven numbers are supplied as 32-bit floating point numbers. The tags are 32-bit signed integers. The endianness is the same as the system you are running on. If you are working with python, the relevant numpy datatype is the following: import numpy as np electron_dtype = np.dtype([ ('x', '=f'), ('y', '=f'), ('z', '=f'), ('dx', '=f'), ('dy', '=f'), ('dz', '=f'), ('E', '=f'), ('px', '=i'), ('py', '=i')]) Example scripts showing how to read and write electron files are provided with the tutorials and in the scripts repository .","title":"Nebula electron file format"},{"location":"nebula-format-tri/","text":"Nebula geometry format The \"geometry file\" encodes the interfaces between volumes as triangles. It is a text file, where each line represents a triangle. There are 11 numbers per line. The first two are integers, representing the materials on either side; the others represent the coordinates of the triangle vertices in nanometers. The order is (mat_in mat_out) (x1 y1 z1) (x2 y2 z2) (x2 y3 z3) where parentheses were added for clarity. We are in a right-handed coordinate system. The \"normal\" direction of the triangle is defined as [(x2 y2 z2)-(x1 y1 z1)] \u00d7 [(x3 y3 z3)-(x1 y1 z1)] where \u00d7 is the cross product. This normal points into the direction that is represented by mat_out . Example: 0 -123 -100 -100 0 100 -100 0 100 100 0 0 -123 -100 -100 0 100 100 0 -100 100 0 These two triangles form a square plane between (x,y) = (-100, -100) and (x,y) = (100, 100), at z = 0. In this case, the outer products are (200, 0, 0) \u00d7 (200, 200, 0) = (0, 0, 40000) and (200, 200, 0) \u00d7 (0, 200, 0) = (0, 0, 40000). So both normals are in the positive z direction. Material -123 is on the +z side and material 0 is on the -z side. Positive material indices correspond to the materials you provide on the command line. You can use more than one material in the simulation, in which case you would run, for example, ./nebula tri pri silicon silicondioxide pmma . In that case, silicon would be material 0, silicondioxide would be material 1 and pmma would be material 2. There are a few special materials, with negative indices: -122 Ideal mirror -123 Vacuum -124 BSE detector: detect the electron if it has 50eV or more, pass it through otherwise -125 SE detector: detect the electron if it has less than 50eV, pass it through otherwise -126 Detector: detect the electron -127 Terminator: kills every electron that tries to move into this material -128 Does nothing","title":"Geometry file format"},{"location":"nebula-format-tri/#nebula-geometry-format","text":"The \"geometry file\" encodes the interfaces between volumes as triangles. It is a text file, where each line represents a triangle. There are 11 numbers per line. The first two are integers, representing the materials on either side; the others represent the coordinates of the triangle vertices in nanometers. The order is (mat_in mat_out) (x1 y1 z1) (x2 y2 z2) (x2 y3 z3) where parentheses were added for clarity. We are in a right-handed coordinate system. The \"normal\" direction of the triangle is defined as [(x2 y2 z2)-(x1 y1 z1)] \u00d7 [(x3 y3 z3)-(x1 y1 z1)] where \u00d7 is the cross product. This normal points into the direction that is represented by mat_out . Example: 0 -123 -100 -100 0 100 -100 0 100 100 0 0 -123 -100 -100 0 100 100 0 -100 100 0 These two triangles form a square plane between (x,y) = (-100, -100) and (x,y) = (100, 100), at z = 0. In this case, the outer products are (200, 0, 0) \u00d7 (200, 200, 0) = (0, 0, 40000) and (200, 200, 0) \u00d7 (0, 200, 0) = (0, 0, 40000). So both normals are in the positive z direction. Material -123 is on the +z side and material 0 is on the -z side. Positive material indices correspond to the materials you provide on the command line. You can use more than one material in the simulation, in which case you would run, for example, ./nebula tri pri silicon silicondioxide pmma . In that case, silicon would be material 0, silicondioxide would be material 1 and pmma would be material 2. There are a few special materials, with negative indices: -122 Ideal mirror -123 Vacuum -124 BSE detector: detect the electron if it has 50eV or more, pass it through otherwise -125 SE detector: detect the electron if it has less than 50eV, pass it through otherwise -126 Detector: detect the electron -127 Terminator: kills every electron that tries to move into this material -128 Does nothing","title":"Nebula geometry format"},{"location":"nebula-install/","text":"Installing Nebula Requirements Nebula needs the following software to be available: cmake 3.18 or greater hdf5 1.8.13 or greater, including the high-level libraries Optionally: CUDA 9.2 or greater (to run on GPUs) A C++14-compliant compiler, such as gcc 5 or later Getting Nebula Via the command line with git installed: git clone https://github.com/nebula-simulator/nebula Alternatively, via a web browser without git installed, you can download the zip file from github. Compiling Nebula Start your terminal and go to the folder in which you placed Nebula (at the same level as the and source folders). We're going to compile the simulator in a new folder called build : mkdir build cd build cmake .. make This will make a new folder called build in which all temporary build files are written. The final executables are located in build/bin . The cmake step will attempt to locate the HDF5 libraries and a CUDA compiler. If it complains that the HDF5 library cannot be found, you can provide a location by passing -DHDF5_ROOT=<xxx> to the cmake command. If a CUDA compiler is not found, the build step will not build a GPU version of the simulator. If you are running CUDA version 10 or earlier, you probably need to install the cub library from nvidia. It comes included with CUDA 11 and later. You can download it here . Then, instead of running cmake .. as above, you should run cmake -DCMAKE_CUDA_STANDARD_INCLUDE_DIRECTORIES=/path/to/cub .. where the /path/to/cub folder is the top-level folder of cub, that is, the one with the readme file in it. Making Nebula available In order to make Nebula available as a command, you need to add it to your PATH environment variable. To do this, add the following line to your ~/.bashrc file: export PATH=$PATH:/path/to/nebula/build/bin Alternatively, you can perform that command manually every time you start a new terminal session. You can find /path/to/nebula/ by typing pwd when you are in the Nebula folder.","title":"Installation"},{"location":"nebula-install/#installing-nebula","text":"","title":"Installing Nebula"},{"location":"nebula-install/#requirements","text":"Nebula needs the following software to be available: cmake 3.18 or greater hdf5 1.8.13 or greater, including the high-level libraries Optionally: CUDA 9.2 or greater (to run on GPUs) A C++14-compliant compiler, such as gcc 5 or later","title":"Requirements"},{"location":"nebula-install/#getting-nebula","text":"Via the command line with git installed: git clone https://github.com/nebula-simulator/nebula Alternatively, via a web browser without git installed, you can download the zip file from github.","title":"Getting Nebula"},{"location":"nebula-install/#compiling-nebula","text":"Start your terminal and go to the folder in which you placed Nebula (at the same level as the and source folders). We're going to compile the simulator in a new folder called build : mkdir build cd build cmake .. make This will make a new folder called build in which all temporary build files are written. The final executables are located in build/bin . The cmake step will attempt to locate the HDF5 libraries and a CUDA compiler. If it complains that the HDF5 library cannot be found, you can provide a location by passing -DHDF5_ROOT=<xxx> to the cmake command. If a CUDA compiler is not found, the build step will not build a GPU version of the simulator. If you are running CUDA version 10 or earlier, you probably need to install the cub library from nvidia. It comes included with CUDA 11 and later. You can download it here . Then, instead of running cmake .. as above, you should run cmake -DCMAKE_CUDA_STANDARD_INCLUDE_DIRECTORIES=/path/to/cub .. where the /path/to/cub folder is the top-level folder of cub, that is, the one with the readme file in it.","title":"Compiling Nebula"},{"location":"nebula-install/#making-nebula-available","text":"In order to make Nebula available as a command, you need to add it to your PATH environment variable. To do this, add the following line to your ~/.bashrc file: export PATH=$PATH:/path/to/nebula/build/bin Alternatively, you can perform that command manually every time you start a new terminal session. You can find /path/to/nebula/ by typing pwd when you are in the Nebula folder.","title":"Making Nebula available"},{"location":"nebula-run/","text":"Running Nebula After you have compiled nebula, the build/bin folder contains two or three executables: nebula_gpu : This is the main simulator program that runs on the GPU. It is only compiled if a CUDA compiler was found on the system. nebula_cpu_mt : This is a multi-threaded CPU-only version. nebula_cpu_edep : A special CPU-only version that outputs locations inside the sample where energy was lost. Invoking via the command line Each of the programs is run with the following signature: ./nebula [options] geometry.tri primaries.pri material1.hdf5 [...] materialN.hdf5 The exact file formats of the geometry and primary electrons are described in detail on separate pages. We also provide tutorials and that should get you up and running with your first simulations. The geometry file labels materials by numbers. These numbers are directly related to the order in which materials are supplied to the command line. Material 0 in the geometry file refers to the first material supplied to the command line, 1 in the geometry file refers to the second material on the command line, and so on. The simulator sends its output (which is in a binary format) to the standard output. This output should be redirected to a file or a program that analyses the output on-the-fly. Redirecting to a file works as follows: ./nebula (parameters) > target_file Command line parameters The other options may be supplied in the format --key = value . Each of the executables has the following available options: seed : Sets the random seed. The seed is not randomized by default. Note though, that if the simulation runs on multiple GPUs or CPU cores simultaneously, work is assigned to threads in an unpredictable manner. So for reproducibility, the simulation must always be run on a single GPU or CPU core. energy-threshold : Sets the lowest energy (w.r.t. vacuum level) to be included in the simulation. By default, this is zero, so all electrons that can reach the vacuum are simulated. Increasing this setting means that electrons are taken out of the simulation sooner, which can lead to big speedups. nebula_gpu has a few options specific to running the simulator on a GPU. These are mostly a consequence of the fact that we cannot dynamically allocate more memory on the GPU. The options are: batch-factor : New electrons must be added to the simulation in batches. Before the simulation starts, the simulator does a \"prescan\" to find out how often a batch needs to be added, and how big it must be. It is possible, though, that the prescan accidentally chooses too large a batch size. You will then see the simulation getting stuck. Reducing the batch factor then lets you reduce the batch size and avoid the simulation getting stuck. The default value is 0.9. capacity : The maximal number of electrons that can be simulated at once. There is a large performance penalty for setting this too small, and a small penalty for setting it too large. It does not affect the simulation results. The default value works well for all GPUs we tested. If the simulation gets stuck, then changing the capacity will not help, as the batch size scales with the capacity. prescan-size : Number of electrons to use in the prescan. Large values will result in a more accurate prescan, but it will take more time. sort-primaries : Whether to sort the primary electrons before simulating. Sorting them (by starting position) speeds up the simulation itself, but the time spent sorting them usually costs more than is saved. Disabled by default. Finally, nebula_cpu_edep has two types of output: the regular output with detected electrons, and the energy deposition data. Therefore, it has the following additional options: detect-filename : File name to send the data for detected electrons to. This is detected.bin by default. deposit-filename : File name to send the data for energy deposits to. By default, this is sent to the standard output.","title":"Running"},{"location":"nebula-run/#running-nebula","text":"After you have compiled nebula, the build/bin folder contains two or three executables: nebula_gpu : This is the main simulator program that runs on the GPU. It is only compiled if a CUDA compiler was found on the system. nebula_cpu_mt : This is a multi-threaded CPU-only version. nebula_cpu_edep : A special CPU-only version that outputs locations inside the sample where energy was lost.","title":"Running Nebula"},{"location":"nebula-run/#invoking-via-the-command-line","text":"Each of the programs is run with the following signature: ./nebula [options] geometry.tri primaries.pri material1.hdf5 [...] materialN.hdf5 The exact file formats of the geometry and primary electrons are described in detail on separate pages. We also provide tutorials and that should get you up and running with your first simulations. The geometry file labels materials by numbers. These numbers are directly related to the order in which materials are supplied to the command line. Material 0 in the geometry file refers to the first material supplied to the command line, 1 in the geometry file refers to the second material on the command line, and so on. The simulator sends its output (which is in a binary format) to the standard output. This output should be redirected to a file or a program that analyses the output on-the-fly. Redirecting to a file works as follows: ./nebula (parameters) > target_file","title":"Invoking via the command line"},{"location":"nebula-run/#command-line-parameters","text":"The other options may be supplied in the format --key = value . Each of the executables has the following available options: seed : Sets the random seed. The seed is not randomized by default. Note though, that if the simulation runs on multiple GPUs or CPU cores simultaneously, work is assigned to threads in an unpredictable manner. So for reproducibility, the simulation must always be run on a single GPU or CPU core. energy-threshold : Sets the lowest energy (w.r.t. vacuum level) to be included in the simulation. By default, this is zero, so all electrons that can reach the vacuum are simulated. Increasing this setting means that electrons are taken out of the simulation sooner, which can lead to big speedups. nebula_gpu has a few options specific to running the simulator on a GPU. These are mostly a consequence of the fact that we cannot dynamically allocate more memory on the GPU. The options are: batch-factor : New electrons must be added to the simulation in batches. Before the simulation starts, the simulator does a \"prescan\" to find out how often a batch needs to be added, and how big it must be. It is possible, though, that the prescan accidentally chooses too large a batch size. You will then see the simulation getting stuck. Reducing the batch factor then lets you reduce the batch size and avoid the simulation getting stuck. The default value is 0.9. capacity : The maximal number of electrons that can be simulated at once. There is a large performance penalty for setting this too small, and a small penalty for setting it too large. It does not affect the simulation results. The default value works well for all GPUs we tested. If the simulation gets stuck, then changing the capacity will not help, as the batch size scales with the capacity. prescan-size : Number of electrons to use in the prescan. Large values will result in a more accurate prescan, but it will take more time. sort-primaries : Whether to sort the primary electrons before simulating. Sorting them (by starting position) speeds up the simulation itself, but the time spent sorting them usually costs more than is saved. Disabled by default. Finally, nebula_cpu_edep has two types of output: the regular output with detected electrons, and the energy deposition data. Therefore, it has the following additional options: detect-filename : File name to send the data for detected electrons to. This is detected.bin by default. deposit-filename : File name to send the data for energy deposits to. By default, this is sent to the standard output.","title":"Command line parameters"},{"location":"tutorial-reels/","text":"REELS tutorial Before you begin this tutorial, make sure you have followed these steps: Install cstool Run cstool for a material of interest (for example, silicon). Install nebula Introduction This first tutorial teaches you to do a Reflection Electron Energy Loss Spectroscopy (REELS) experiment. The idea is simple: a thick and large sample is irradiated with electrons from above. Electrons that are emitted back up from the sample (in the \"reflection\" direction) reach a detector. We are interested in the energy distribution of these electrons. Input geometry A triangle file can be downloaded here. Open it in a text editor and take a look. The exact meaning of these numbers are documented here . The first two triangles are the sample-vacuum interface at z = 0. They form a square, ranging from -500nm to +500nm in both the x and y directions. The next two lines represent a detector at z = 10nm. You may notice that material -126, the detector material, is on both sides of this plane. Shouldn't we have vacuum on the bottom side? No, because the simulator only cares about the material you are going towards . So we must put the detector material on the upper side, but it doesn't matter what we put on the bottom side because electrons will never go that way. The four pairs of lines after that are mirrors, with material -122, representing the \"sides\" of the box. Again, we must put material -122 on the outside, and it doesn't matter what we put on the inside. The mirrors make sure that electrons which reach the edge of the simulation volume are reflected back into the simulation, so we don't lose them. Finally, there are also \"terminators\" (material -127) at z = -10 \u03bcm. This is necessary because the \"simulation domain\" is given by the extent of the geometry. If an electron leaves the simulation domain, it is removed. So if you want to simulate a 10 \u03bcm thick sample, you need to put triangles at that depth. The reason why we choose terminators instead of mirrors is that if we put mirrors here, the geometry will look like a 20 \u03bcm thick sample with detectors on both sides. Of course, if we want to simulate an infinitely thick sample we must make sure that the bottom plane is never reached by the electrons. But we now say that if the bottom plane is reached for whatever reason, we prefer to kill these electrons. Input electrons We will launch a million 1 keV primary electrons from z = 5 nm. This position is nicely between the surface of the sample (at z = 0) and the detectors (at z = 10 nm). A python script to generate such a primary electron file can be downloaded here . The relevant part of the script looks like this: import numpy as np # Parameters: x = 0 # starting x y = 0 # starting y z = 5 # starting z N = 1000000 # Number of electrons energy = 1000 # Beam energy, in eV # Open file with open('reels.pri', 'wb') as file: # Allocate numpy buffer buffer = np.empty(N, dtype=electron_dtype) # Fill with data buffer['x'] = x buffer['y'] = y buffer['z'] = z buffer['dx'] = 0 buffer['dy'] = 0 buffer['dz'] = -1 buffer['E'] = energy buffer['px'] = 0 buffer['py'] = 0 # Write buffer to file buffer.tofile(file) The interesting part starts at with open('reels.pri', 'wb') as file: . This opens a file, reels.pri , for writing in binary format. The next line of code reserves a buffer that we will fill with the data for our primary electrons. N is the size of the buffer (number of primary electrons); electron_dtype is the data type described here . We then fill the buffer with data, setting the parameters for all N electrons to be the same. The last line writes this buffer to file. Running the simulator Now, let us generate the primary electrons and run the simulator: python reels-pri.py nebula_gpu reels.tri reels.pri silicon.mat > output.det If you do not have the GPU version installed, please replace nebula_gpu by nebula_cpu_mt in the last command. After running these commands, should have an output.det file, which contains the detected electrons. Analyzing the output To analyze the output, download the analysis script . This script reads the detected electrons, makes a histogram of their energy, and shows this in a plot. You can run it as follows: python reels-analysis.py output.det You should see following energy spectrum:","title":"REELS"},{"location":"tutorial-reels/#reels-tutorial","text":"Before you begin this tutorial, make sure you have followed these steps: Install cstool Run cstool for a material of interest (for example, silicon). Install nebula","title":"REELS tutorial"},{"location":"tutorial-reels/#introduction","text":"This first tutorial teaches you to do a Reflection Electron Energy Loss Spectroscopy (REELS) experiment. The idea is simple: a thick and large sample is irradiated with electrons from above. Electrons that are emitted back up from the sample (in the \"reflection\" direction) reach a detector. We are interested in the energy distribution of these electrons.","title":"Introduction"},{"location":"tutorial-reels/#input-geometry","text":"A triangle file can be downloaded here. Open it in a text editor and take a look. The exact meaning of these numbers are documented here . The first two triangles are the sample-vacuum interface at z = 0. They form a square, ranging from -500nm to +500nm in both the x and y directions. The next two lines represent a detector at z = 10nm. You may notice that material -126, the detector material, is on both sides of this plane. Shouldn't we have vacuum on the bottom side? No, because the simulator only cares about the material you are going towards . So we must put the detector material on the upper side, but it doesn't matter what we put on the bottom side because electrons will never go that way. The four pairs of lines after that are mirrors, with material -122, representing the \"sides\" of the box. Again, we must put material -122 on the outside, and it doesn't matter what we put on the inside. The mirrors make sure that electrons which reach the edge of the simulation volume are reflected back into the simulation, so we don't lose them. Finally, there are also \"terminators\" (material -127) at z = -10 \u03bcm. This is necessary because the \"simulation domain\" is given by the extent of the geometry. If an electron leaves the simulation domain, it is removed. So if you want to simulate a 10 \u03bcm thick sample, you need to put triangles at that depth. The reason why we choose terminators instead of mirrors is that if we put mirrors here, the geometry will look like a 20 \u03bcm thick sample with detectors on both sides. Of course, if we want to simulate an infinitely thick sample we must make sure that the bottom plane is never reached by the electrons. But we now say that if the bottom plane is reached for whatever reason, we prefer to kill these electrons.","title":"Input geometry"},{"location":"tutorial-reels/#input-electrons","text":"We will launch a million 1 keV primary electrons from z = 5 nm. This position is nicely between the surface of the sample (at z = 0) and the detectors (at z = 10 nm). A python script to generate such a primary electron file can be downloaded here . The relevant part of the script looks like this: import numpy as np # Parameters: x = 0 # starting x y = 0 # starting y z = 5 # starting z N = 1000000 # Number of electrons energy = 1000 # Beam energy, in eV # Open file with open('reels.pri', 'wb') as file: # Allocate numpy buffer buffer = np.empty(N, dtype=electron_dtype) # Fill with data buffer['x'] = x buffer['y'] = y buffer['z'] = z buffer['dx'] = 0 buffer['dy'] = 0 buffer['dz'] = -1 buffer['E'] = energy buffer['px'] = 0 buffer['py'] = 0 # Write buffer to file buffer.tofile(file) The interesting part starts at with open('reels.pri', 'wb') as file: . This opens a file, reels.pri , for writing in binary format. The next line of code reserves a buffer that we will fill with the data for our primary electrons. N is the size of the buffer (number of primary electrons); electron_dtype is the data type described here . We then fill the buffer with data, setting the parameters for all N electrons to be the same. The last line writes this buffer to file.","title":"Input electrons"},{"location":"tutorial-reels/#running-the-simulator","text":"Now, let us generate the primary electrons and run the simulator: python reels-pri.py nebula_gpu reels.tri reels.pri silicon.mat > output.det If you do not have the GPU version installed, please replace nebula_gpu by nebula_cpu_mt in the last command. After running these commands, should have an output.det file, which contains the detected electrons.","title":"Running the simulator"},{"location":"tutorial-reels/#analyzing-the-output","text":"To analyze the output, download the analysis script . This script reads the detected electrons, makes a histogram of their energy, and shows this in a plot. You can run it as follows: python reels-analysis.py output.det You should see following energy spectrum:","title":"Analyzing the output"},{"location":"tutorial-sem/","text":"SEM image tutorial Before you begin this tutorial, make sure you have followed these steps: Install cstool Run cstool for two materials: silicon and pmma Install nebula We also recommend to follow the REELS tutorial first, because this one will be more complicated. Introduction In this second tutorial, we will simulate a Scanning Electron Microscope (SEM) image. To keep things simple, the geometry we will be looking at is a single PMMA line on top of a silicon substrate. This is a common situation in lithography: the PMMA represents a developed line of photoresist on top of a silicon substrate. We are interested in a secondary electron (SE) image of this geometry. Input geometry A triangle file can be downloaded here. Open it in a text editor and take a look: it is more complicated than the geometry for the REELS tutorial. The first six triangles represent the substrate. All are at z = 0. The first pair of triangles is an interface between material 0 (substrate) and -123 (vacuum) for x < 20 nm. The second pair of triangles is between materials 0 (substrate) and 1 (resist); the x coordinates run from -20 nm to +20 nm. The last pair of triangles is again a substrate-vacuum interface for x > 20 nm. The three following pairs of triangles represent the three sides of the line: first at x = -20 nm, then at z = 30 nm, and finally at x = + 20 nm. All of these have material 1 (resist) on one side and -123 (vacuum) on the other. All this is wrapped in a similar box as in the REELS tutorial: a detector above (at z = 40 nm this time, because it must be above the line), mirrors on the sides, and a terminator deep down in the substrate. This time, though, the detector has material index -125 instead of -126. Material -126 detects all electrons, but material -125 detects only the low-energy (< 50 eV) electrons. These \"secondary electrons\" (SEs) contain information about the shape of the sample. High-energy > 50 eV \"backscattered electrons\" (BSEs) do not contain much shape information, but are more sensitive to material composition instead. Right now, we are interested in SEs. If a BSE hits a detector of material -125, it passes through. In our geometry, that means it leaves the simulation box and is taken out of the simulation. An alternative approach to using material -125 is to use material -126, and apply an energy filter in post-processing. That's fine of course, but this approach means that the output files from the simulator will be a bit smaller. Input electrons We will launch 500 eV primary electrons from z = 35 nm, nicely between the top of the line (at z = 30) and the detectors (at z = 40 nm). We are now interested in a SEM image, so the electrons will start on a grid in the xy plane. To mimic a real SEM even more accurately, the number of electrons per pixel will be variable (assuming Poissonian statistics) and the beam spot will be Gaussian, with \u03c3 = 1 nm. A python script to generate such a primary electron file can be downloaded here . The relevant part of the script looks like this: # Parameters z = 35 # starting z xpx = np.linspace(-50, 50, 101) # x pixels: between -50nm and +50nm, in steps of 1nm ypx = np.linspace(-100, 100, 201) # y pixels: between -100nm and +100nm, in steps of 1nm energy = 500 # Beam energy, in eV epx = 100 # Number of electrons per pixel sigma = 1 # Standard deviation of Gaussian beam spot size poisson = True # Whether to use Poisson shotnoise # Open file with open('sem.pri', 'wb') as file: # Iterate over pixels for i, xmid in enumerate(xpx): for j, ymid in enumerate(ypx): # Number of electrons in this specific pixel N_elec = np.random.poisson(epx) if poisson else epx # Allocate numpy buffer buffer = np.empty(N_elec, dtype=electron_dtype) # Fill with data buffer['x'] = np.random.normal(xmid, sigma, N_elec) buffer['y'] = np.random.normal(ymid, sigma, N_elec) buffer['z'] = z buffer['dx'] = 0 buffer['dy'] = 0 buffer['dz'] = -1 buffer['E'] = energy buffer['px'] = i buffer['py'] = j # Write buffer to file buffer.tofile(file) As before , the first set of lines defines a few parameters. xpx and ypx are a list of pixel coordinates, in nm: the function np.linspace(start, stop, num) generates an array of num evenly-spaced numbers between start and stop . After opening the output file, there is a nested for-loop over the pixels in the image. enumerate() means that you get both the index of the value in an array, here i and j ; as well as the actual value ( xmid and ymid ). We will need the indices for the pixel indices, and the actual values for the real beam positions in nanometers. We then determine the number of electrons that will land at this specific pixel. If the poisson parameter was true, this is a random number; otherwise we use the target value. We then allocate a buffer of exactly the number of electrons we want to send into this pixel. The buffer can then be filled. The x and y coordinates of the electrons are random, normally distributed around xmid and ymid as discussed above. The function np.randon.normal(mu, sigma, size) generates an array of random numbers of length size . So, in these two lines, we set buffer['x'] and buffer['y'] to an array of values with the same length as the buffer itself. The other parameters are set to scalars, which means to fill the entire buffer with the same value. In the last line, we write the buffer to file and the loop continues with the next pixel. Running the simulator We will now generate the primary electrons and run the simulator: python sem-pri.py nebula_gpu sem.tri sem.pri silicon.mat pmma.mat > output.det If you do not have the GPU version, replace nebula_gpu by nebula_cpu_mt for a CPU-only simulation. Analyzing the output To analyze the output, download the analysis script . To make a SEM image, we need to count the number of detected electrons per pixel. We do this with numpy's histogram2d() function. You can run the script as follows: python sem-analysis.py output.det You should see the following SEM image:","title":"SEM image"},{"location":"tutorial-sem/#sem-image-tutorial","text":"Before you begin this tutorial, make sure you have followed these steps: Install cstool Run cstool for two materials: silicon and pmma Install nebula We also recommend to follow the REELS tutorial first, because this one will be more complicated.","title":"SEM image tutorial"},{"location":"tutorial-sem/#introduction","text":"In this second tutorial, we will simulate a Scanning Electron Microscope (SEM) image. To keep things simple, the geometry we will be looking at is a single PMMA line on top of a silicon substrate. This is a common situation in lithography: the PMMA represents a developed line of photoresist on top of a silicon substrate. We are interested in a secondary electron (SE) image of this geometry.","title":"Introduction"},{"location":"tutorial-sem/#input-geometry","text":"A triangle file can be downloaded here. Open it in a text editor and take a look: it is more complicated than the geometry for the REELS tutorial. The first six triangles represent the substrate. All are at z = 0. The first pair of triangles is an interface between material 0 (substrate) and -123 (vacuum) for x < 20 nm. The second pair of triangles is between materials 0 (substrate) and 1 (resist); the x coordinates run from -20 nm to +20 nm. The last pair of triangles is again a substrate-vacuum interface for x > 20 nm. The three following pairs of triangles represent the three sides of the line: first at x = -20 nm, then at z = 30 nm, and finally at x = + 20 nm. All of these have material 1 (resist) on one side and -123 (vacuum) on the other. All this is wrapped in a similar box as in the REELS tutorial: a detector above (at z = 40 nm this time, because it must be above the line), mirrors on the sides, and a terminator deep down in the substrate. This time, though, the detector has material index -125 instead of -126. Material -126 detects all electrons, but material -125 detects only the low-energy (< 50 eV) electrons. These \"secondary electrons\" (SEs) contain information about the shape of the sample. High-energy > 50 eV \"backscattered electrons\" (BSEs) do not contain much shape information, but are more sensitive to material composition instead. Right now, we are interested in SEs. If a BSE hits a detector of material -125, it passes through. In our geometry, that means it leaves the simulation box and is taken out of the simulation. An alternative approach to using material -125 is to use material -126, and apply an energy filter in post-processing. That's fine of course, but this approach means that the output files from the simulator will be a bit smaller.","title":"Input geometry"},{"location":"tutorial-sem/#input-electrons","text":"We will launch 500 eV primary electrons from z = 35 nm, nicely between the top of the line (at z = 30) and the detectors (at z = 40 nm). We are now interested in a SEM image, so the electrons will start on a grid in the xy plane. To mimic a real SEM even more accurately, the number of electrons per pixel will be variable (assuming Poissonian statistics) and the beam spot will be Gaussian, with \u03c3 = 1 nm. A python script to generate such a primary electron file can be downloaded here . The relevant part of the script looks like this: # Parameters z = 35 # starting z xpx = np.linspace(-50, 50, 101) # x pixels: between -50nm and +50nm, in steps of 1nm ypx = np.linspace(-100, 100, 201) # y pixels: between -100nm and +100nm, in steps of 1nm energy = 500 # Beam energy, in eV epx = 100 # Number of electrons per pixel sigma = 1 # Standard deviation of Gaussian beam spot size poisson = True # Whether to use Poisson shotnoise # Open file with open('sem.pri', 'wb') as file: # Iterate over pixels for i, xmid in enumerate(xpx): for j, ymid in enumerate(ypx): # Number of electrons in this specific pixel N_elec = np.random.poisson(epx) if poisson else epx # Allocate numpy buffer buffer = np.empty(N_elec, dtype=electron_dtype) # Fill with data buffer['x'] = np.random.normal(xmid, sigma, N_elec) buffer['y'] = np.random.normal(ymid, sigma, N_elec) buffer['z'] = z buffer['dx'] = 0 buffer['dy'] = 0 buffer['dz'] = -1 buffer['E'] = energy buffer['px'] = i buffer['py'] = j # Write buffer to file buffer.tofile(file) As before , the first set of lines defines a few parameters. xpx and ypx are a list of pixel coordinates, in nm: the function np.linspace(start, stop, num) generates an array of num evenly-spaced numbers between start and stop . After opening the output file, there is a nested for-loop over the pixels in the image. enumerate() means that you get both the index of the value in an array, here i and j ; as well as the actual value ( xmid and ymid ). We will need the indices for the pixel indices, and the actual values for the real beam positions in nanometers. We then determine the number of electrons that will land at this specific pixel. If the poisson parameter was true, this is a random number; otherwise we use the target value. We then allocate a buffer of exactly the number of electrons we want to send into this pixel. The buffer can then be filled. The x and y coordinates of the electrons are random, normally distributed around xmid and ymid as discussed above. The function np.randon.normal(mu, sigma, size) generates an array of random numbers of length size . So, in these two lines, we set buffer['x'] and buffer['y'] to an array of values with the same length as the buffer itself. The other parameters are set to scalars, which means to fill the entire buffer with the same value. In the last line, we write the buffer to file and the loop continues with the next pixel.","title":"Input electrons"},{"location":"tutorial-sem/#running-the-simulator","text":"We will now generate the primary electrons and run the simulator: python sem-pri.py nebula_gpu sem.tri sem.pri silicon.mat pmma.mat > output.det If you do not have the GPU version, replace nebula_gpu by nebula_cpu_mt for a CPU-only simulation.","title":"Running the simulator"},{"location":"tutorial-sem/#analyzing-the-output","text":"To analyze the output, download the analysis script . To make a SEM image, we need to count the number of detected electrons per pixel. We do this with numpy's histogram2d() function. You can run the script as follows: python sem-analysis.py output.det You should see the following SEM image:","title":"Analyzing the output"}]}